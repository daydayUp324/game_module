# 跳表

**参考链接：**

[设计跳表](https://leetcode.cn/problems/design-skiplist/solutions/1696545/she-ji-tiao-biao-by-leetcode-solution-e8yh/)

**题目链接：**

[1206. 设计跳表](https://leetcode.cn/problems/design-skiplist/description/)

## 介绍

跳表这种数据结构是由 $\text{William Pugh}$ 发明的。跳表是一种随机化的数据结构，可以被看做二叉树的一个变种，它在性能上和红黑树、$\texttt{AVL}$ 树不相上下，但是跳表的原理非常简单，目前在 $\texttt{Redis}$ 和 $\texttt{LevelDB}$ 中都有用到。跳表的期望空间复杂度为 $O(n)$，跳表的查询，插入和删除操作的期望时间复杂度均为 $O(\log n)$。跳表实际为一种多层的有序链表，跳表的每一层都为一个 **有序链表**，且满足每个位于第 $i$ 层的节点有 $p$ 的概率出现在第 $i+1$ 层，其中 $p$ 为常数。

跳表在进行查找时，首先从当前的最高层 $L(n)$ 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第一层。此时，若下一个节点是目标节点，则成功查找；反之，则元素不存在。由于从高层往低层开始查找，由于低层出现的元素可能不会出现在高层，因此跳表在进行查找的过程中会跳过一些元素，相比于有序链表的查询，跳表的查询速度会更快。

跳表的 **初始化、查找、添加、删除** 操作详细描述如下：

- **initial：** 设置跳表的最大层数 $\textit{MAX\_LEVEL}$ 和
- **search：** 从跳表的当前的最大层数 $\textit{level}$ 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第 $1$ 层。此时，若第 $1$ 层的下一个节点的值等于 $\textit{target}$，则返回 $\texttt{true}$；反之，则返回 $\texttt{false}$。
- **add：** 从跳表的当前的最大层数 $\textit{level}$ 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第 $1$ 层。设新加入的节点为 $\textit{newNode}$，我们需要计算出此次节点插入的层数 $\textit{lv}$，如果 $\textit{level}$ 小于 $\textit{lv}$，则同时需要更新 $\textit{level}$。我们用数组 $\textit{update}$ 保存每一层查找的最后一个节点，第 $i$ 层最后的节点为 $\textit{update}[i]$。我们将 $\textit{newNode}$ 的后续节点指向 $\textit{update}[i]$ 的下一个节点，同时更新 $\textit{update}[i]$ 的后续节点为 $\textit{newNode}$。
- **erase：** 首先我们需要查找当前元素是否存在跳表中。从跳表的当前的最大层数 $\textit{level}$ 层开始查找，在当前层水平地逐个比较直至当前节点的下一个节点大于等于目标节点，然后移动至下一层进行查找，重复这个过程直至到达第 $1$ 层。如果第 $1$ 层的下一个节点不等于 $\textit{num}$ 时，则表示当前元素不存在直接返回。我们用数组 $\textit{update}$ 保存每一层查找的最后一个节点，第 $i$ 层最后的节点为 $\textit{update}[i]$。此时第 $i$ 层的下一个节点的值为 $\textit{num}$，则我们需要将其从跳表中将其删除。由于第 $i$ 层的以 $p$ 的概率出现在第 $i+1$ 层，因此我们应当从第 $1$ 层开始往上进行更新，将 $\textit{num}$ 从 $\textit{update}[i]$ 的下一跳中删除，同时更新 $\textit{update}[i]$ 的后续节点，直到当前层的链表中没有出现 $\textit{num}$ 的节点为止。最后我们还需要更新跳表中当前的最大层数 $\textit
{level}$。

**复杂度的分析：**

+ 空间复杂度分析：我们知道每次添加节点时，节点出现在第 $i$ 层的概率为 $(1-p)\times p^{i-1}$，跳表插入时的期望层数为:

$$
\begin{aligned}
E(L) &= 1 \times (1-p) + 2 \times (1-p)\times p + 3 \times (1-p) \times p^2 + \cdots \\
&= \sum_{i=1}^{\infty} i \times (1-p) \times p^{i-1} \\
&= (1-p) \times \sum_{i=1}^{\infty} i \times p^{i-1} \\
&= (1-p) \times \dfrac{1}{(1-p)^2} \\
&= \dfrac{1}{1-p}
\end{aligned}
$$

如果节点的目标层数为 $L$，则此时需要的空间为 $O(L)$，因此总的空间复杂度为 $O(n \times E(L)) = O(n \times \dfrac{1}{1-p}) = O(n)$。 

+ 时间复杂度分析: 在含有 $n$ 个节点的跳表中，当前最大层数 $L(n)$ 包含的元素个数期望为 $\dfrac{1}{p}$，根据跳表的定义可以知道第 $1$ 层的每个元素出现在 $L(n)$ 的概率为 $p^{L(n)-1}$，则此时我们可以推出如下：

$$
\begin{aligned}
\dfrac{1}{p} &= np^{L(n)-1} \\
p^{L(n)} &= \dfrac{1}{n} \\
L(n) &= \log_p {\dfrac{1}{n}}
\end{aligned}
$$

根据以上结论可以知道在含有 $n$ 个节点的跳表中，当前最大层数期望 $L(n) = \log_p {\dfrac{1}{n}}$。

我们首先思考一下搜索目标节点 $x$ 的过程，每次我们搜索第 $i$ 层时，如果第 $i$ 层的当前节点小于 $x$ 时，则我们会在第 $i$ 层向右进行搜索，直到下一个节点的值大于等于 $x$；如果第 $i$ 层的节点值大于等于 $x$，则我们则会下降到 $i-1$ 层。根据之前的定义，如果节点 $x$ 在第 $i$ 层出现，则节点 $x$ 一定会出现在第 $i-1$ 层。现在假设我们从 $L(n)$ 的第一个节点搜索到第 $1$ 层的目标节点 $x$ 的路径为 $S$，现在我们将路径 $S$ 反过来，即从第 $1$ 的节点 $x$ 回到 $L(n)$ 层的第一个节点，我们可以观察到从第 $1$ 层的节点 $x$ 一直往上一层，直到 $x$ 的最大层数，然后再向左走一步到达节点 $y$，再向上走，再重复上述步骤，实际搜索时如果在上一层可以到访问到节点 $x$，则在下一层遍历时一定不会访问所有小于 $x$ 的节点。假设当前我们处于一个第 $i$ 层的节点 $x$，此时并不知道 $x$ 的最大层数和 $x$ 左侧节点的最大层数，只知道 $x$ 的最大层数至少为 $i$。我们可以知道 $x$ 的最大层数大于 $i$，那么下一步按照最优选择应该是向上一层，这种情况的概率为 $p$；如果 $x$ 的最大层数等于 $i$，那么下一步应该是同一层向左侧后退一个节点，这种情况概率为 $1-p$。令 $C(i)$ 为在一个无限长度的跳表中向上爬 $i$ 层的期望代价，则知道:

$$
\begin{aligned}
C(0) &= 0 \\
C(i) &= (1-p)(1 + C(i)) + p(1 + C(i-1)) \\
C(i) &= \dfrac{1}{p} + C(i-1) \\
C(i) &= \dfrac{i}{p}
\end{aligned}
$$

在含有 $n$ 个元素的跳表中，从第 $1$ 层爬到第 $L(n)$ 层的期望步数存在上界 $\dfrac{L(n) - 1}{p}$。现在只需要分析爬到第 $L(n)$ 层后还要再走多少步。当达到第 $L(n)$ 层后，我们需要向左走。我们已知 $L(n)$ 层的节点总数的期望存在上界为 $\dfrac{1}{p}$。所以我们知道搜索的总的代价为:

$$
\dfrac{L(n) - 1}{p} + \dfrac{1}{p} = \dfrac{\log_{\frac{1}{p}}n -1}{p} + \dfrac{1}{p} =  \dfrac{\log_{\frac{1}{p}}n}{p}
$$

根据以上推理可以得到查询的平均时间复杂度为 $O(\log n)$。

### 代码

完整代码具体见 `MySkiplist.h`