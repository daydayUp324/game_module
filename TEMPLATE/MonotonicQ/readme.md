#

## 单调队列 (MonotonicQuque)

需要不断维护队列的单调性，时刻保证队列元素 **从大到小** 或 **从小到大**
前置知识：**双指针**
以固定窗口大小的区间最大值为例（此时维护的是一个从大到小的单调队列）：
每次向右移动一格左指针，在移动前，如果左指针指向的元素在队首左侧，说明左指针指向的元素小于队首，移动左指针不会改变区间最大值，直接移动左指针即可；
如果左指针指向的就是队首，那么移动左指针会使区间最大值变小（变为单调队列队首之后的那个元素），我们要弹出队首。
这样无论是何种情况，都保证了在移动左指针后，单调队列的队首始终为当前区间的最大值。名称虽然是单调队列，但是实际实现并不是用普通队列来实现，而是用双端队列来实
现的。

实现具体见 : `MonotonicQ.h`

### Problem1

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

**问题描述：**

给你一个整数数组 $nums$，有一个大小为 $k$ 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 $k$ 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

**输入：**$nums = [1,3,-1,-3,5,3,6,7] ,k = 3$
**输出：**$[3,3,5,5,6,7]$
**解释：**

滑动窗口的位置 |       最大值
---          |       ---
[1  3  -1] -3  5  3  6  7    |   3
 1 [3  -1  -3] 5  3  6  7    |   3
 1  3 [-1  -3  5] 3  6  7    |   5
 1  3  -1 [-3  5  3] 6  7    |   5
 1  3  -1  -3 [5  3  6] 7    |   6
 1  3  -1  -3  5 [3  6  7]   |   7

**思路分析：**

那么用一个 **单调队列** 来维护窗口移动过程中的单调性即可：对于现在遍历到的数字，如果队列非空，且大于队尾的数字，那么此时队尾的数字在接下来一定不会被用到，那么直接删除即可，直至队列为空或者队列队尾元素大于当前遍历元素。因为整个队列都是单调增的，所以队头元素即为当前窗口的最大元素。

**代码参考：**

具体见 `Problem/LC239.h`

### Problem2

[2373. 矩阵中的局部最大值](https://leetcode.cn/problems/largest-local-values-in-a-matrix/)

[HAOI2007 理想的正方形](https://www.luogu.com.cn/problem/P2216)

两个题目等价

**问题描述 :**

有一个 $a \times b$ 的整数组成的矩阵，现请你从中找出一个 $n \times n$ 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。

**输入格式：**

第一行为 $3$ 个整数，分别表示 $a,b,n$ 的值。

第二行至第 $a+1$ 行每行为 $b$ 个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。

**输出格式：**

仅一个整数，为 $a \times b$ 矩阵中所有“ $n \times n$ 正方形区域中的最大整数和最小整数的差值”的最小值。

**样例 #1**

**样例输入 #1**

```
5 4 2
1 2 5 6
0 17 16 0
16 17 2 1
2 10 2 1
1 2 2 2
```

**样例输出 #1**

```
1
```

**提示：**

问题规模。

矩阵中的所有数都不超过 $1,000,000,000$。

$20\%$ 的数据 $2 \le a,b \le 100,n \le a,n \le b,n \le 10$。

$100\%$ 的数据 $2 \le a,b \le 1000,n \le a,n \le b,n \le 100$。

**思路分析：**

首先如果朴实的做法就是对每一个小窗来计算窗口中的最大值，这样整个时间复杂度就是 $a \times b \times n \times n$ 肯定是会超时的，那么我们考虑如果对于每一个行，首先求得每一个大小为 $n$ 的窗口的每一个位置的最大值 $line[i][j]$ 表示行 $i$ 的第 $j$ 个窗口中的最大值。那么对于第一个 $n \times n$ 的窗口中的最大值就是 $\max\{line[0][0] \dots line[0][n - 1]\}$，窗口往下移动一个单位后的最大值就是 $\max\{line[0][1] \dots line[0][n]\}$。那么窗口的最大值实质上也就是 $line[0]$ 的列方向上的一个 $n$ 大小的窗口的最大值，就是对应窗口的最大值。又因为原数组的空间可以再利用，所以用 $nums[i][j]$ 表示 $nums[i][j-n+1:j]$ 的一个最大值。

**Code：**

具体见 `Problem/LC2373.h` 和 `Problem/LuoguP2216.cpp`
