#

**参考链接** : [最小生成树](https://oi-wiki.org/graph/mst/)

## 最小生成树 (Minimum Spanning Tree)

有 `n` 个结点的连通图的生成树是原图的 `极小连通子图` ，且包含原图中的所有 `n` 个结点，并且有保持图连通的最少的边。

`最小生成树` 可以用 `kruskal（克鲁斯卡尔）算法` 或 `prim（普里姆）算法` 求出。

### Kruskal 算法

`Kruskal 算法` 是一种 `贪心` 算法 , 它每次加入不破坏的 `生成树` 定义的 `最小权重边` , 可以用 `并查集` 来维护当前的 `生成树`，每次加入边进行判断即可。

#### 应用_1

找 `图` 中的 `关键边` 和 `伪关键边` (也可以用 `次小生成树` 来解决)

相关题目 : [1489. 找到最小生成树里的关键边和伪关键边](https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/)

具体可以见代码 `T1489.h`

#### CODE_1

具体见 `MSTKruskal.h`

#### 时间复杂度_1

1. 边的排序 : $O(ElogE)$
2. 判断加入边后是否连通 : $O(logV)$

所以总的时间复杂度 : $O(E * max(logE,logV))$

### Prim 算法

Prim 算法是另一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。具体来说，每次要选择距离最小的一个结点，以及用新的边更新其他结点的距离。

其实跟 Dijkstra 算法一样，每次找到距离最小的一个点，可以暴力找也可以用堆维护。

#### CODE_2

具体见 `MSTPrim.h`

#### 时间复杂度_2

1. $O(n)$ , 每次加点的次数
2. $O(n)$ , 每次找 `最短边` 的开销

所以总的 **时间复杂度** 为 : $O(n^2)$

---

## 次小生成树

### 定义_1

在 `无向图` 中，边权和最小的满足边权和 **大于等于** `最小生成树边权和` 的 `生成树`

### 求法_1

求出无向图的最小生成树 `T` ，设其权值和为 `M`
遍历每条未被选中的边 `e = (u,v,w)` ，找到 `T` 中 `u` 到 `v` 路径上边权最大的一条边 `e' = (s,t,w')` ，则在 `T`  中以 `e` 替换 `e'` ，可得一棵权值和为 `M' = M + w - w'` 的生成树 `T'` .
对所有替换得到的答案 `M'` 取最小值即可
如何求 `u,v` 路径上的边权最大值呢？

> 我们可以使用 **倍增** 来维护，预处理出每个节点的 $2^i$ 级祖先及到达其 $2^i$ 级祖先路径上最大的边权，这样在倍增求 `LCA` 的过程中可以直接求得。

## 严格次小生成树

### 定义_2

在 `无向图` 中，边权和最小的满足边权和 **大于等于** `最小生成树边权和` 的 `生成树`

### 求法_2

考虑刚才的非严格次小生成树求解过程，为什么求得的解是非严格的？

因为最小生成树保证生成树中 `u` 到 `v` 路径上的边权最大值一定 **不大于** 其他从 `u` 到 `v` 路径的边权最大值。换言之，当我们用于替换的边的权值与原生成树中被替换边的权值相等时，得到的次小生成树是非严格的。

解决的办法很自然：我们维护到 $2^i$ 级祖先路径上的最大边权的同时维护 **严格次大边权**，当用于替换的边的权值与原生成树中路径最大边权相等时，我们用严格次大值来替换即可。

这个过程可以用 **倍增** 求解，复杂度 $O(m*logm)$

### CODE_3

相关题目 : [P4180 [BJWC2010]严格次小生成树](https://www.luogu.com.cn/problem/P4180)

具体见 `SubSmallST.h`
