#

**参考链接** : [最小生成树](https://oi-wiki.org/graph/mst/)

## 最小生成树 (Minimum Spanning Tree)

有 `n` 个结点的连通图的生成树是原图的 `极小连通子图` ，且包含原图中的所有 `n` 个结点，并且有保持图连通的最少的边。

`最小生成树` 可以用 `kruskal（克鲁斯卡尔）算法` 或 `prim（普里姆）算法` 求出。

### Kruskal 算法

`Kruskal 算法` 是一种 `贪心` 算法 , 它每次加入不破坏的 `生成树` 定义的 `最小权重边` , 可以用 `并查集` 来维护当前的 `生成树`，每次加入边进行判断即可。

#### CODE_1

具体见 `MST.h`

#### 时间复杂度_1

1. 边的排序 : $O(ElogE)$
2. 判断加入边后是否连通 : $O(logV)$

所以总的时间复杂度 : $O(E * max(logE,logV))$

### Prim 算法

Prim 算法是另一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。具体来说，每次要选择距离最小的一个结点，以及用新的边更新其他结点的距离。

其实跟 Dijkstra 算法一样，每次找到距离最小的一个点，可以暴力找也可以用堆维护。

#### CODE_2

具体见 `MST.h`

#### 时间复杂度_2

1. $O(n)$ , 每次加点的次数
2. $O(n)$ , 每次找 `最短边` 的开销

所以总的 **时间复杂度** 为 : $O(n^2)$
