#

## 树相关知识总结

---

### 树的重心

__参考链接 :__ [树的重心](https://oi-wiki.org/graph/tree-centroid/)

#### 定义

> 对于树上的每一个点，计算其所有子树中最大的子树节点数，这个值最小的点就是这棵树的重心。

#### 性质

1. 以 __树的重心__ 为根时 , 所有子树的大小都不超过整棵树大小的一半
2. 树中所有点到某个点的距离和中，到 __重心__ 的 __距离和__ 是最小的；如果有两个 __重心__ ，那么到它们的距离和一样。
3. 把两棵树通过一条边相连得到一棵新的树，那么新的树的 __重心__ 在连接原来两棵树的重心的路径上。
4. 在一棵树上添加或删除一个叶子，那么它的 __重心__ 最多只移动一条边的距离。

#### 求重心_CODE

利用 上述 `性质 1` + `DFS` 可以求得 :

1. 对于某一个 `节点 i` 我们判断它的 `DFS` 方向的子树大小是否都不超过整颗树的一半
2. 然后因为是树 , 所以 `节点 i` 最多只有一个 `父节点` 而树的 `总节点数 n` 是确定的 , 所以用 `n` 减去 `DFS` 方向上的全部子树大小和 `节点 i` 本身 即可。

```cpp
// n 为节点总数
// m 为总结点一半 : m = n / 2
vector<int> res;// 重心的点
vector<vector<int>> g;// 树的无向图表达
int n,m;
int dfs(int cur,int pre) {
    int sz = 1;
    bool f = true;
    for(auto& next : g[cur]) {
        if(next == pre) continue;
        int t = dfs(next,cur);
        sz += t;
        if(t > m) f = false;
    }
    if(f && n - sz > m) f = false;
    if(f) res.push_back(cur);
    return sz;
}
```

