#

参考链接 : [Tarjan 求 LCA](https://www.cnblogs.com/wozaixuexi/p/8974731.html)

---

## tarjan 求 Least Common Ancestor (LCA)

`LCA (Least Common Ancestor)` : 顾名思义，是指在一棵树中，距离两个点最近的两者的公共节点。也就是说，在两个点通往根的道路上，肯定会有公共的节点，我们就是要求找到公共的节点中，深度尽量深的点。还可以表示成另一种说法，就是如果把树看成是一个图，这找到这两个点中的最短距离。

`LCA` 算法有在线算法也有离线算法，所谓的 `在线算法` 就是实时性的 (比如 `倍增法` 求 `LCA`)，而 `离线算法` 则是要求一次性读入所有的请求，然后在统一得处理。而在处理的过程中不一定是按照请求的输入顺序来处理的。说不定后输入的请求在算法的执行过程中是被先处理的。

---

`tarjan 算法` 是基于 `并查集` 和 `DFS` 的 `离线算法`。`Tarjan 算法` 的复杂度为 `O(N+Q)`，`Q` 为询问的次数。相当于一次性批量处理，一开始就知道了全部查询，只待询问。

---

如果需要求 `(u,v)` 之间的路径长度 `dis` :

1. 先求出 `LCA(u,v) = root`
2. `dis = depth[u] + depth[v] - depth[root]`

---

### 算法思想

我们考虑每一个查询 `(x,y)` 的可能情况 :

1. `y` 是 `x` 的某一个子节点 (`x,y` 互换亦然) , 那么 `LCA(x,y) = x`
2. `y` 和 `x` 是某一个节点 `u` 的两棵不同子树 , 那么 `LCA(x,y) = u`

`Tarjan` 是基于 `DFS` 的算法 , 在回溯 `(u->v)`(`u` 为 `v` 的一个子节点) 时 , 因为对于 `u` 的能处理的查询都接受了 , 那么如果有一个查询 `(u,x)` 是符合上述情况一的 , 那么肯定是已经处理了 , 所以 `LCA(u,x) = LCA(v,x)` , 即我们将 `u,v` "合并" 即可。

那么在从根节点 `root` 往下搜索的过程中 , 当遇到了 `y` 我们判断 `x` 是否已经处理过：

1. 如果处理过 , `LCA(y,x) = fa[x]` , `fa[x]` 表示 `x` 的所在区域
2. 如果没有处理过就跳过

### CODE

参考题目 : [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

具体见 `Solution/tarjan_lca.h` 和 `Problem/LuoguP3379.cpp`
