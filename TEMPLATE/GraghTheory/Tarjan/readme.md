#

## tarjan 算法

**参考链接** [Tarjan算法：求解图的割点与桥（割边）](https://www.cnblogs.com/nullzx/p/7968110.html)

### 应用范围

1. 求割点✔️
   - 题目链接 : [P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)
   - 题目链接 : [1568. 使陆地分离的最少天数](https://leetcode-cn.com/problems/minimum-number-of-days-to-disconnect-island/)
2. 求割边✔️
   - 题目链接 : [1192. 查找集群内的「关键连接」](https://leetcode-cn.com/problems/critical-connections-in-a-network/)
3. 求 SCC
4. 求 DCC
5. 求 BCC
6. 求 LCA (求公共祖先)

### 预备知识

`强连通` : 图中的任意两个点都可以相互到达
`割点` : 无向连通图中，去掉一个顶点及和它相邻的所有边，图中的连通分量数增加，则该顶点称为割点。
`割边` : 无向联通图中，去掉一条边，图中的连通分量数增加，则这条边，称为桥或者割边。

- 注意 : 有 **割点** 的图不一定存在 **割边** , 有 **割边** 的图一定存在 **割点**

`DFS搜索树` : 用DFS对图进行遍历时，按照遍历次序的不同，我们可以得到一棵 **DFS搜索树**
`树边` : DFS过程中访问 **未访问节点** 时所经过的边。
`回边` : 在DFS过程中遇到 **已访问节点** 时所经过的边。
`强连通分量(strongly connected components,SCC)` : 非强连通图有向图的 **极大强连通子图**，称为 **强连通分量**
`边双连通分量` : 给定一张无向图 G ，如果不存在 **割边**，则称为边双连通图，无向图的 **极大边双连通分量** 被称为 **边双连通分量**
`点双连通分量（简称双连通分量,Biconnected Component,BCC）` : 在一个无向图中，若任意两点间至少存在两条“点不重复”的路径，则说这个图是 **点双连通的**

---

#### 算法核心

1. 首先分析 **暴力求解** 无向图中的 **割点** 和 **割边** :

    > 暴力法的原理就是通过定义求解割点和割边。在图中去掉某个顶点，然后进行DFS遍历，如果连通分量增加，那么该顶点就是割点。如果在图中去掉某条边，然后进行DFS遍历，如果连通分量增加，那么该边就是割边。对每个顶点或者每个边进行一次上述操作，就可以求出这个图的所有割点和割边，我们称之为这个图的割点集和割边集。
    >
    > 在具体的代码实现中，并不需要真正删除该顶点和删除依附于该顶点所有边。对于割点，我们只需要在DFS前，将该顶点对应是否已访问的标记置为ture，然后从其它顶点为根进行DFS即可。对于割边，我们只需要禁止从这条边进行DFS后，如果联通分量增加了，那么这条边就是割边。

2. **tarjan** 思想

    > 判断一个顶点是不是割点除了从定义，还可以从DFS（深度优先遍历）的角度出发。我们先通过DFS定义两个概念。
    >
    > 假设DFS中我们从顶点U访问到了顶点V（此时顶点V还未被访问过），那么我们称顶点U为顶点V的父顶点，V为U的孩子顶点。在顶点U之前被访问过的顶点，我们就称之为U的祖先顶点。
    >
    > 显然如果顶点U的所有孩子顶点可以不通过父顶点U而访问到U的祖先顶点，那么说明此时去掉顶点U不影响图的连通性，U就不是割点。相反，如果顶点U至少存在一个孩子顶点，必须通过父顶点U才能访问到U的祖先顶点，那么去掉顶点U后，顶点U的祖先顶点和孩子顶点就不连通了，说明U是一个割点。
    >
    > 而对于根节点 是否是割点 需要特别判断 , 因为根节点没有 祖先节点 , 我们可以通过从 根节点 出发它的子树个数来判断即可 , 如果有两个或以上的子树 , 那么就说明根节点为 割点

---

### 算法流程

#### 定义变量

1. `dfn[i]` : `dnf[]` 的下标表示顶点的编号，数组中的值表示该顶点在 `DFS` 中的遍历顺序(或者说 `时间戳`)，每访问到一个未访问过的顶点，访问顺序的值（时间戳）就增加1。子顶点的dfn值一定比父顶点的dfn值大（但不一定恰好大1，比如父顶点有两个及两个以上分支的情况）。在访问一个顶点后，它的dfn的值就确定下来了，不会再改变。
2. `low[i]` : `low[]` 的下标表示顶点的编号，数组中的值表示 `DFS` 中该顶点不通过父顶点能访问到的祖先顶点中最小的顺序值（或者说时间戳）。**每个顶点初始的low值和dfn值应该一样，在DFS中，我们根据情况不断更新low的值。**
   - **注意** : `low[i]` 最终的值 **不一定** 不和其父节点的 `dfn[]` 不同

#### 代码流程

代码具体见 : `tarjan.h`

1. `DFS` 构造一个 `生成树`
2. 在 `DFS` 中更新 `low[]` 和 `dfn[]` 数组
   - `u->v` 为 **树边** `low[u] = min(low[u],low[v])`
   - `u->v` 为 **回边** , 且 v 不是 u 的父亲节点 `low[u] = min(low[u],dfn[v])`
3. 对于某一个 `节点i` (除根节点外)是否是割点 , 我们用 `low[j] >= dfn[i]` 来判断 (`low[j] >= dfn[i]` 说明不能通过 `i` 的祖先节点到达 `j` , 说明把 `i` 删除后 `j` 不可达 , 即 `i` 是一个割点) , 其中 `j` 为 `i` 的一个子节点 (**注意 : 即 (i->j) 为一条树边**)
4. 对于某一条边 (`u->v`) 是否是桥 : 如果 `low[v] > dnf[u]` , 说明把该边删除后 , `u` 的任意一个 `祖先节点` 不能通过其他的边到达 `u` , 即符合割边的定义。
