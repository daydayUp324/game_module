#

参考链接 : [四大算法解决最短路径问题](https://www.cnblogs.com/AlvinZH/p/6789912.html)

## 最短路

最短路主要方法主要四种 : `Dijkstra` , `SPFA` , `Folyd` , `Bellman_ford`

具体代码看对应的 `.h` 文件即可

### Dijkstra

`单源最短路模型` : 用于计算一个节点到其他所有节点的最短路径。

主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。

**基本思想 :**

把 `带权图` 中所有的点分为两部分 S∪U，S为已经求出从起点到该点的最短路径的点集合，U中为未确定最短路径的点集合。把U中的点一个一个加入到S中，最后求出全部最短路径。

如何把U中的点加入S中呢？

1. 初始时，S只包含 源点s，即 `S＝{s}` ，`dis[s]=0`。U 包含除 v 外的其他顶点，即 U={其余顶点}，若 s 与 U 中顶点 u 有边，则 `dis[u]=e[s][u]`，否则，`dis[u]=INF`。
2. 从 U 中找到一个与 源点s 距离最小 —— `min{dis[k]}` 的顶点 k，把 k 加入 S 中，`dis[k]` 确定
3. 以 k 为新考虑的中间点，修改 源点s 到 U 中各顶点的距离 `dis[]` : `dis[k]+e[k][u] < dis[u]`，则修改 `dis[k]` , 修改后的距离值的顶点 k 的距离加上边上的权。(这一过程称为 **"松弛"**)
4. 重复 `步骤2和3` 直到所有顶点都包含在S中。

**处理问题 : 单源、无负权、有向图、无向图最短路径**

**不能适用情况 : 含有负边权**

---

### Folyd

Floyd算法的基本思想如下：

从任意 `节点A` 到任意 `节点B` 的最短路径不外乎 2种可能 :

1. 直接从A到B
2. 从A经过若干个节点X到B。

所以，我们假设 `Dis(A,B)` 为节点A到节点B的最短路径的距离，对于每一个节点X，我们检查 `Dis(A,X) + Dis(X,B) < Dis(A,B)` 是否成立，如果成立，证明从A到X再到B的路径比A直接到B的路径短，我们便设置 `Dis(A,B) = Dis(A,X) + Dis(X,B)`，这样一来，当我们遍历完所有节点X，`Dis(A,B)` 中记录的便是A到B的最短路径的距离。 

**核心代码**

```cpp
for(int i = 1;i <= n;i ++) {
    // 每一个点加入进行松弛
    for(int j = 1;j <= n;j ++) {
        for(int k = 1;k <= n;k ++) {
            if(j == k) continue;
            if(dis[j][i] + dis[i][k] < dis[j][k]) {
                dis[j][k] = dis[j][i] + dis[i][k];
                path[j][k] = i;
            }
        }
    }
}
```

**处理问题：多源、可有负权、有向图、无向图最短路径**

---

### Bellman_ford

`Dijkstra` 算法是处理 `单源最短路径` 的有效算法，但它局限于边的权值 **非负** 的情况，若图中出现权值为负的边，`Dijkstra` 算法就会失效，求出的最短路径就可能是错的。这时候，就需要使用其他的算法来求解最短路径，`Bellman-Ford` 算法就是其中最常用的一个。该算法由美国数学家理查德•贝尔曼（Richard Bellman, 动态规划的提出者）和小莱斯特•福特（Lester Ford）发明。Bellman-Ford算法的流程如下：

给定图 `G(V, E)`（其中V、E分别为图G的顶点集与边集），源点s

1. 数组 `Distant[i]`  记录从 `源点s` 到 `顶点i` 的路径长度，初始化数组 `Distant[s] = 0`
2. 以下操作循环执行至多 n-1 次，n 为顶点数
对于每一条边 `e(u, v)` ，如果 `Distant[u] + w(u, v) < Distant[v]` ，则另 `Distant[v] = Distant[u]+w(u, v)` 。`w(u, v)` 为边 `e(u,v)` 的权值。若上述操作没有对 `Distant[]` 进行更新，说明最短路径已经查找完毕，或者部分点不可达，跳出循环。否则执行下次循环
3. 为了检测图中是否存在 **负环路**，即权值之和小于0的环路。对于每一条边 `e(u, v)` ，如果存在 `Distant[u] + w(u, v) < Distant[v]` 的边，则图中存在 `负环路`，即是说改图无法求出单源最短路径。否则数组 `Distant[]` 中记录的就是 `源点s` 到各顶点的最短路径长度

可知，`Bellman-Ford` 算法寻找单源最短路径的时间复杂度为 `O(V*E)`

**处理问题：多源、可有负权、有向图、无向图最短路径**

---

### SPFA

`Bellman_ford` 算法其实不好用，复杂度太高 , `SPFA` 算法是 `Bellman-ford` 算法的队列优化，比较常用。`SPFA` 算法在负边权图上可以完全取代 `Bellman-ford` 算法，另外在稀疏图中也表现良好。但是在非负边权图中，为了避免最坏情况的出现，通常使用效率更加稳定的 `Dijkstra` 算法，以及它的使用 `堆优化` 的版本。通常的 `SPFA` 算法在一类网格图中的表现不尽如人意。不是很稳定，不如 `Dijkstra`。

**算法思想 :** 设立一个队列用来保存待优化的点，优化时每次取出队首 结点 u，并且用 u 点当前的最短路径估计值对 u 点所指向的结点 v 进行 **松弛操作**，如果 v 点的最短路径估计值有所调整，且 v 点不在当前的队列中，就将 v 点放入队尾。这样不断从队列中取出结点来进行 **松弛操作**，直至队列空为止。

**处理问题 : 单源、可有负权、有向图、无向图最短路径**